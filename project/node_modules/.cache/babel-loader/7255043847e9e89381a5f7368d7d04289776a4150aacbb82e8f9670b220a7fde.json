{"ast":null,"code":"const load = require('loadware');\nconst assert = require('assert');\nconst reply = require('../../reply');\n\n// Recursively resolve possible function returns\nconst processReturn = (ctx, ret) => {\n  if (!ret) return;\n\n  // Use the returned reply instance\n  if (ret.constructor.name === 'Reply') {\n    return ret.exec(ctx);\n  }\n\n  // TODO: make a check for only accepting the right types of return values\n\n  // Create a whole new reply thing\n  const fn = typeof ret === 'number' ? 'status' : 'send';\n  return reply[fn](ret).exec(ctx);\n};\n\n// Pass an array of modern middleware and return a single modern middleware\nmodule.exports = (...middles) => {\n  // Flattify all of the middleware\n  const middle = load(middles);\n\n  // Go through each of them\n  return async ctx => {\n    for (const mid of middle) {\n      try {\n        if (ctx.req.solved) return;\n\n        // DO NOT MERGE; the else is relevant only for ctx.error\n        if (ctx.error) {\n          // See if this middleware can fix it\n          if (mid.error) {\n            assert(mid.error instanceof Function, 'Error handler should be a function');\n            const ret = await mid.error(ctx);\n            await processReturn(ctx, ret);\n            if (ctx.res.headersSent) {\n              ctx.req.solved = true;\n            }\n          }\n        }\n        // No error, call next middleware. Skips middleware if there's an error\n        else {\n          const ret = await mid(ctx);\n          await processReturn(ctx, ret);\n          if (ctx.res.headersSent) {\n            ctx.req.solved = true;\n          }\n        }\n      } catch (err) {\n        ctx.error = err;\n      }\n    }\n  };\n};","map":{"version":3,"names":["load","require","assert","reply","processReturn","ctx","ret","constructor","name","exec","fn","module","exports","middles","middle","mid","req","solved","error","Function","res","headersSent","err"],"sources":["/home/lillian/node_modules/server/src/join/index.js"],"sourcesContent":["const load = require('loadware');\nconst assert = require('assert');\nconst reply = require('../../reply');\n\n// Recursively resolve possible function returns\nconst processReturn = (ctx, ret) => {\n  if (!ret) return;\n\n  // Use the returned reply instance\n  if (ret.constructor.name === 'Reply') {\n    return ret.exec(ctx);\n  }\n\n  // TODO: make a check for only accepting the right types of return values\n\n  // Create a whole new reply thing\n  const fn = typeof ret === 'number' ? 'status' : 'send';\n  return reply[fn](ret).exec(ctx);\n};\n\n// Pass an array of modern middleware and return a single modern middleware\nmodule.exports = (...middles) => {\n\n  // Flattify all of the middleware\n  const middle = load(middles);\n\n  // Go through each of them\n  return async ctx => {\n    for (const mid of middle) {\n      try {\n        if (ctx.req.solved) return;\n\n        // DO NOT MERGE; the else is relevant only for ctx.error\n        if (ctx.error) {\n          // See if this middleware can fix it\n          if (mid.error) {\n            assert(mid.error instanceof Function, 'Error handler should be a function');\n            const ret = await mid.error(ctx);\n            await processReturn(ctx, ret);\n            if (ctx.res.headersSent) {\n              ctx.req.solved = true;\n            }\n          }\n        }\n        // No error, call next middleware. Skips middleware if there's an error\n        else {\n          const ret = await mid(ctx);\n          await processReturn(ctx, ret);\n          if (ctx.res.headersSent) {\n            ctx.req.solved = true;\n          }\n        }\n      } catch (err) {\n        ctx.error = err;\n      }\n    }\n  };\n};\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,UAAU,CAAC;AAChC,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAME,KAAK,GAAGF,OAAO,CAAC,aAAa,CAAC;;AAEpC;AACA,MAAMG,aAAa,GAAGA,CAACC,GAAG,EAAEC,GAAG,KAAK;EAClC,IAAI,CAACA,GAAG,EAAE;;EAEV;EACA,IAAIA,GAAG,CAACC,WAAW,CAACC,IAAI,KAAK,OAAO,EAAE;IACpC,OAAOF,GAAG,CAACG,IAAI,CAACJ,GAAG,CAAC;EACtB;;EAEA;;EAEA;EACA,MAAMK,EAAE,GAAG,OAAOJ,GAAG,KAAK,QAAQ,GAAG,QAAQ,GAAG,MAAM;EACtD,OAAOH,KAAK,CAACO,EAAE,CAAC,CAACJ,GAAG,CAAC,CAACG,IAAI,CAACJ,GAAG,CAAC;AACjC,CAAC;;AAED;AACAM,MAAM,CAACC,OAAO,GAAG,CAAC,GAAGC,OAAO,KAAK;EAE/B;EACA,MAAMC,MAAM,GAAGd,IAAI,CAACa,OAAO,CAAC;;EAE5B;EACA,OAAO,MAAMR,GAAG,IAAI;IAClB,KAAK,MAAMU,GAAG,IAAID,MAAM,EAAE;MACxB,IAAI;QACF,IAAIT,GAAG,CAACW,GAAG,CAACC,MAAM,EAAE;;QAEpB;QACA,IAAIZ,GAAG,CAACa,KAAK,EAAE;UACb;UACA,IAAIH,GAAG,CAACG,KAAK,EAAE;YACbhB,MAAM,CAACa,GAAG,CAACG,KAAK,YAAYC,QAAQ,EAAE,oCAAoC,CAAC;YAC3E,MAAMb,GAAG,GAAG,MAAMS,GAAG,CAACG,KAAK,CAACb,GAAG,CAAC;YAChC,MAAMD,aAAa,CAACC,GAAG,EAAEC,GAAG,CAAC;YAC7B,IAAID,GAAG,CAACe,GAAG,CAACC,WAAW,EAAE;cACvBhB,GAAG,CAACW,GAAG,CAACC,MAAM,GAAG,IAAI;YACvB;UACF;QACF;QACA;QAAA,KACK;UACH,MAAMX,GAAG,GAAG,MAAMS,GAAG,CAACV,GAAG,CAAC;UAC1B,MAAMD,aAAa,CAACC,GAAG,EAAEC,GAAG,CAAC;UAC7B,IAAID,GAAG,CAACe,GAAG,CAACC,WAAW,EAAE;YACvBhB,GAAG,CAACW,GAAG,CAACC,MAAM,GAAG,IAAI;UACvB;QACF;MACF,CAAC,CAAC,OAAOK,GAAG,EAAE;QACZjB,GAAG,CAACa,KAAK,GAAGI,GAAG;MACjB;IACF;EACF,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}