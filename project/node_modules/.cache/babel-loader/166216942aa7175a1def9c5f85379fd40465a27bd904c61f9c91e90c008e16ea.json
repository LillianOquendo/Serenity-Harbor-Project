{"ast":null,"code":"const join = require('../src/join');\nconst parse = require('./parse');\nconst {\n  match\n} = require('path-to-regexp');\nconst decode = decodeURIComponent;\nmodule.exports = (...all) => {\n  // Extracted or otherwise it'd shift once per call; also more performant\n  const {\n    path,\n    middle\n  } = parse(all);\n\n  // Convert to the proper path, since the new ones use `(.*)` instead of `*`\n  const parsePath = match(path.replace(/\\*/g, '(.*)'), {\n    decode: decode\n  });\n  const generic = () => {};\n  generic.error = async ctx => {\n    // Only do this if the correct path\n    ctx.error.code = ctx.error.code || '';\n    ctx.error.params = parsePath(ctx.error.code).params;\n\n    // Add an extra-allowing initial matching\n    if (!ctx.error.params && ctx.error.code.slice(0, path.length) !== path) return;\n    const ret = await middle[0](ctx);\n    delete ctx.error;\n    return ret;\n  };\n  return generic;\n};","map":{"version":3,"names":["join","require","parse","match","decode","decodeURIComponent","module","exports","all","path","middle","parsePath","replace","generic","error","ctx","code","params","slice","length","ret"],"sources":["/home/lillian/node_modules/server/router/error.js"],"sourcesContent":["const join = require('../src/join');\nconst parse = require('./parse');\nconst { match } = require('path-to-regexp');\n\nconst decode = decodeURIComponent;\n\nmodule.exports = (...all) => {\n  // Extracted or otherwise it'd shift once per call; also more performant\n  const { path, middle } = parse(all);\n\n  // Convert to the proper path, since the new ones use `(.*)` instead of `*`\n  const parsePath = match(path.replace(/\\*/g, '(.*)'), { decode: decode });\n\n  const generic = () => {};\n  generic.error = async ctx => {\n\n    // Only do this if the correct path\n    ctx.error.code = ctx.error.code || '';\n    ctx.error.params = parsePath(ctx.error.code).params;\n\n    // Add an extra-allowing initial matching\n    if (!ctx.error.params && ctx.error.code.slice(0, path.length) !== path) return;\n\n    const ret = await middle[0](ctx);\n    delete ctx.error;\n    return ret;\n  };\n  return generic;\n};\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,aAAa,CAAC;AACnC,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAChC,MAAM;EAAEE;AAAM,CAAC,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAE3C,MAAMG,MAAM,GAAGC,kBAAkB;AAEjCC,MAAM,CAACC,OAAO,GAAG,CAAC,GAAGC,GAAG,KAAK;EAC3B;EACA,MAAM;IAAEC,IAAI;IAAEC;EAAO,CAAC,GAAGR,KAAK,CAACM,GAAG,CAAC;;EAEnC;EACA,MAAMG,SAAS,GAAGR,KAAK,CAACM,IAAI,CAACG,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;IAAER,MAAM,EAAEA;EAAO,CAAC,CAAC;EAExE,MAAMS,OAAO,GAAGA,CAAA,KAAM,CAAC,CAAC;EACxBA,OAAO,CAACC,KAAK,GAAG,MAAMC,GAAG,IAAI;IAE3B;IACAA,GAAG,CAACD,KAAK,CAACE,IAAI,GAAGD,GAAG,CAACD,KAAK,CAACE,IAAI,IAAI,EAAE;IACrCD,GAAG,CAACD,KAAK,CAACG,MAAM,GAAGN,SAAS,CAACI,GAAG,CAACD,KAAK,CAACE,IAAI,CAAC,CAACC,MAAM;;IAEnD;IACA,IAAI,CAACF,GAAG,CAACD,KAAK,CAACG,MAAM,IAAIF,GAAG,CAACD,KAAK,CAACE,IAAI,CAACE,KAAK,CAAC,CAAC,EAAET,IAAI,CAACU,MAAM,CAAC,KAAKV,IAAI,EAAE;IAExE,MAAMW,GAAG,GAAG,MAAMV,MAAM,CAAC,CAAC,CAAC,CAACK,GAAG,CAAC;IAChC,OAAOA,GAAG,CAACD,KAAK;IAChB,OAAOM,GAAG;EACZ,CAAC;EACD,OAAOP,OAAO;AAChB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}