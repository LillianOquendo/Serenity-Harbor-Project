{"ast":null,"code":"const join = require('../src/join');\nconst parse = require('./parse');\nconst {\n  match\n} = require('path-to-regexp');\nconst decode = decodeURIComponent;\n\n// Generic request handler\nmodule.exports = (method, ...all) => {\n  // Extracted or otherwise it'd shift once per call; also more performant\n  const {\n    path,\n    middle\n  } = parse(all);\n\n  // Convert to the proper path, since the new ones use `(.*)` instead of `*`\n  const parsePath = match(path.replace(/\\*/g, '(.*)'), {\n    decode: decode\n  });\n  return async ctx => {\n    // A route should be solved only once per request\n    if (ctx.req.solved) return;\n\n    // Only for the correct method\n    if (method !== ctx.req.method) return;\n\n    // Only do this if the correct path\n    ctx.req.params = parsePath(ctx.req.path).params;\n    if (!ctx.req.params) return;\n    ctx.params = ctx.req.params;\n\n    // Perform this promise chain\n    await join(middle, ctx => {\n      // Only solve it if all the previous middleware succeeded\n      ctx.req.solved = true;\n      if (!ctx.res.headersSent) {\n        ctx.res.end();\n      }\n    })(ctx);\n  };\n};","map":{"version":3,"names":["join","require","parse","match","decode","decodeURIComponent","module","exports","method","all","path","middle","parsePath","replace","ctx","req","solved","params","res","headersSent","end"],"sources":["/home/lillian/node_modules/server/router/generic.js"],"sourcesContent":["const join = require('../src/join');\nconst parse = require('./parse');\nconst { match } = require('path-to-regexp');\n\nconst decode = decodeURIComponent;\n\n// Generic request handler\nmodule.exports = (method, ...all) => {\n  // Extracted or otherwise it'd shift once per call; also more performant\n  const { path, middle } = parse(all);\n\n  // Convert to the proper path, since the new ones use `(.*)` instead of `*`\n  const parsePath = match(path.replace(/\\*/g, '(.*)'), { decode: decode });\n\n  return async ctx => {\n    // A route should be solved only once per request\n    if (ctx.req.solved) return;\n\n    // Only for the correct method\n    if (method !== ctx.req.method) return;\n\n    // Only do this if the correct path\n    ctx.req.params = parsePath(ctx.req.path).params;\n    if (!ctx.req.params) return;\n    ctx.params = ctx.req.params;\n\n    // Perform this promise chain\n    await join(middle, ctx => {\n      // Only solve it if all the previous middleware succeeded\n      ctx.req.solved = true;\n      if (!ctx.res.headersSent) {\n        ctx.res.end();\n      }\n    })(ctx);\n  };\n};\n"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,aAAa,CAAC;AACnC,MAAMC,KAAK,GAAGD,OAAO,CAAC,SAAS,CAAC;AAChC,MAAM;EAAEE;AAAM,CAAC,GAAGF,OAAO,CAAC,gBAAgB,CAAC;AAE3C,MAAMG,MAAM,GAAGC,kBAAkB;;AAEjC;AACAC,MAAM,CAACC,OAAO,GAAG,CAACC,MAAM,EAAE,GAAGC,GAAG,KAAK;EACnC;EACA,MAAM;IAAEC,IAAI;IAAEC;EAAO,CAAC,GAAGT,KAAK,CAACO,GAAG,CAAC;;EAEnC;EACA,MAAMG,SAAS,GAAGT,KAAK,CAACO,IAAI,CAACG,OAAO,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;IAAET,MAAM,EAAEA;EAAO,CAAC,CAAC;EAExE,OAAO,MAAMU,GAAG,IAAI;IAClB;IACA,IAAIA,GAAG,CAACC,GAAG,CAACC,MAAM,EAAE;;IAEpB;IACA,IAAIR,MAAM,KAAKM,GAAG,CAACC,GAAG,CAACP,MAAM,EAAE;;IAE/B;IACAM,GAAG,CAACC,GAAG,CAACE,MAAM,GAAGL,SAAS,CAACE,GAAG,CAACC,GAAG,CAACL,IAAI,CAAC,CAACO,MAAM;IAC/C,IAAI,CAACH,GAAG,CAACC,GAAG,CAACE,MAAM,EAAE;IACrBH,GAAG,CAACG,MAAM,GAAGH,GAAG,CAACC,GAAG,CAACE,MAAM;;IAE3B;IACA,MAAMjB,IAAI,CAACW,MAAM,EAAEG,GAAG,IAAI;MACxB;MACAA,GAAG,CAACC,GAAG,CAACC,MAAM,GAAG,IAAI;MACrB,IAAI,CAACF,GAAG,CAACI,GAAG,CAACC,WAAW,EAAE;QACxBL,GAAG,CAACI,GAAG,CAACE,GAAG,CAAC,CAAC;MACf;IACF,CAAC,CAAC,CAACN,GAAG,CAAC;EACT,CAAC;AACH,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}