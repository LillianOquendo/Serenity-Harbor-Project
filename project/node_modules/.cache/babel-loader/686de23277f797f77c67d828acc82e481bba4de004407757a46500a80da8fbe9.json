{"ast":null,"code":"// Create a socket plugin\nconst socketIO = require('socket.io');\nconst listeners = {};\nmodule.exports = {\n  name: 'socket',\n  options: {\n    path: {\n      env: 'SOCKET_PATH'\n    },\n    serveClient: {},\n    adapter: {},\n    origins: {},\n    parser: {},\n    pingTimeout: {},\n    pingInterval: {},\n    upgradeTimeout: {},\n    maxHttpBufferSize: {},\n    allowRequest: {},\n    transports: {},\n    allowUpgrades: {},\n    perMessageDeflate: {},\n    httpCompression: {},\n    cookie: {},\n    cookiePath: {},\n    cookieHttpOnly: {},\n    wsEngine: {}\n  },\n  router: (path, middle) => {\n    listeners[path] = listeners[path] || [];\n    listeners[path].push(middle);\n  },\n  launch: ctx => {\n    if (!ctx.options.socket) return;\n    if (listeners.ping) {\n      ctx.log.warning('socket(\"ping\") has a special meaning, please avoid it');\n    }\n    ctx.io = socketIO(ctx.server, ctx.options.socket);\n    ctx.io.on('connect', socket => {\n      // Create a new context assigned to each connected socket\n      const createContext = extra => {\n        return Object.assign({}, socket.client.request, ctx, extra);\n      };\n\n      // Attach a `socket.on('name', cb)` to each of the callbacks\n      for (let path in listeners) {\n        if (path !== 'connect') {\n          listeners[path].forEach(cb => {\n            socket.on(path, data => cb(createContext({\n              path,\n              socket,\n              data\n            })));\n          });\n        }\n      }\n\n      // This is not a callback and should be called straight away since we are\n      // already inside `io.on('connect')`\n      const path = 'connect';\n      if (listeners['connect']) {\n        listeners[path].forEach(cb => cb(createContext({\n          path,\n          socket\n        })));\n      }\n    });\n  }\n};","map":{"version":3,"names":["socketIO","require","listeners","module","exports","name","options","path","env","serveClient","adapter","origins","parser","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","allowRequest","transports","allowUpgrades","perMessageDeflate","httpCompression","cookie","cookiePath","cookieHttpOnly","wsEngine","router","middle","push","launch","ctx","socket","ping","log","warning","io","server","on","createContext","extra","Object","assign","client","request","forEach","cb","data"],"sources":["/home/lillian/node_modules/server/plugins/socket/index.js"],"sourcesContent":["// Create a socket plugin\nconst socketIO = require('socket.io');\n\nconst listeners = {};\n\nmodule.exports = {\n  name: 'socket',\n  options: {\n    path: {\n      env: 'SOCKET_PATH'\n    },\n    serveClient: {},\n    adapter: {},\n    origins: {},\n    parser: {},\n    pingTimeout: {},\n    pingInterval: {},\n    upgradeTimeout: {},\n    maxHttpBufferSize: {},\n    allowRequest: {},\n    transports: {},\n    allowUpgrades: {},\n    perMessageDeflate: {},\n    httpCompression: {},\n    cookie: {},\n    cookiePath: {},\n    cookieHttpOnly: {},\n    wsEngine: {}\n  },\n  router: (path, middle) => {\n    listeners[path] = listeners[path] || [];\n    listeners[path].push(middle);\n  },\n  launch: ctx => {\n    if (!ctx.options.socket) return;\n    if (listeners.ping) {\n      ctx.log.warning('socket(\"ping\") has a special meaning, please avoid it');\n    }\n    ctx.io = socketIO(ctx.server, ctx.options.socket);\n    ctx.io.on('connect', socket => {\n      // Create a new context assigned to each connected socket\n      const createContext = extra => {\n        return Object.assign({}, socket.client.request, ctx, extra);\n      };\n\n      // Attach a `socket.on('name', cb)` to each of the callbacks\n      for (let path in listeners) {\n        if (path !== 'connect') {\n          listeners[path].forEach(cb => {\n            socket.on(path, data => cb(createContext({ path, socket, data })));\n          });\n        }\n      }\n\n      // This is not a callback and should be called straight away since we are\n      // already inside `io.on('connect')`\n      const path = 'connect';\n      if (listeners['connect']) {\n        listeners[path].forEach(cb => cb(createContext({ path, socket })));\n      }\n    });\n  }\n};\n"],"mappings":"AAAA;AACA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,WAAW,CAAC;AAErC,MAAMC,SAAS,GAAG,CAAC,CAAC;AAEpBC,MAAM,CAACC,OAAO,GAAG;EACfC,IAAI,EAAE,QAAQ;EACdC,OAAO,EAAE;IACPC,IAAI,EAAE;MACJC,GAAG,EAAE;IACP,CAAC;IACDC,WAAW,EAAE,CAAC,CAAC;IACfC,OAAO,EAAE,CAAC,CAAC;IACXC,OAAO,EAAE,CAAC,CAAC;IACXC,MAAM,EAAE,CAAC,CAAC;IACVC,WAAW,EAAE,CAAC,CAAC;IACfC,YAAY,EAAE,CAAC,CAAC;IAChBC,cAAc,EAAE,CAAC,CAAC;IAClBC,iBAAiB,EAAE,CAAC,CAAC;IACrBC,YAAY,EAAE,CAAC,CAAC;IAChBC,UAAU,EAAE,CAAC,CAAC;IACdC,aAAa,EAAE,CAAC,CAAC;IACjBC,iBAAiB,EAAE,CAAC,CAAC;IACrBC,eAAe,EAAE,CAAC,CAAC;IACnBC,MAAM,EAAE,CAAC,CAAC;IACVC,UAAU,EAAE,CAAC,CAAC;IACdC,cAAc,EAAE,CAAC,CAAC;IAClBC,QAAQ,EAAE,CAAC;EACb,CAAC;EACDC,MAAM,EAAEA,CAACnB,IAAI,EAAEoB,MAAM,KAAK;IACxBzB,SAAS,CAACK,IAAI,CAAC,GAAGL,SAAS,CAACK,IAAI,CAAC,IAAI,EAAE;IACvCL,SAAS,CAACK,IAAI,CAAC,CAACqB,IAAI,CAACD,MAAM,CAAC;EAC9B,CAAC;EACDE,MAAM,EAAEC,GAAG,IAAI;IACb,IAAI,CAACA,GAAG,CAACxB,OAAO,CAACyB,MAAM,EAAE;IACzB,IAAI7B,SAAS,CAAC8B,IAAI,EAAE;MAClBF,GAAG,CAACG,GAAG,CAACC,OAAO,CAAC,uDAAuD,CAAC;IAC1E;IACAJ,GAAG,CAACK,EAAE,GAAGnC,QAAQ,CAAC8B,GAAG,CAACM,MAAM,EAAEN,GAAG,CAACxB,OAAO,CAACyB,MAAM,CAAC;IACjDD,GAAG,CAACK,EAAE,CAACE,EAAE,CAAC,SAAS,EAAEN,MAAM,IAAI;MAC7B;MACA,MAAMO,aAAa,GAAGC,KAAK,IAAI;QAC7B,OAAOC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEV,MAAM,CAACW,MAAM,CAACC,OAAO,EAAEb,GAAG,EAAES,KAAK,CAAC;MAC7D,CAAC;;MAED;MACA,KAAK,IAAIhC,IAAI,IAAIL,SAAS,EAAE;QAC1B,IAAIK,IAAI,KAAK,SAAS,EAAE;UACtBL,SAAS,CAACK,IAAI,CAAC,CAACqC,OAAO,CAACC,EAAE,IAAI;YAC5Bd,MAAM,CAACM,EAAE,CAAC9B,IAAI,EAAEuC,IAAI,IAAID,EAAE,CAACP,aAAa,CAAC;cAAE/B,IAAI;cAAEwB,MAAM;cAAEe;YAAK,CAAC,CAAC,CAAC,CAAC;UACpE,CAAC,CAAC;QACJ;MACF;;MAEA;MACA;MACA,MAAMvC,IAAI,GAAG,SAAS;MACtB,IAAIL,SAAS,CAAC,SAAS,CAAC,EAAE;QACxBA,SAAS,CAACK,IAAI,CAAC,CAACqC,OAAO,CAACC,EAAE,IAAIA,EAAE,CAACP,aAAa,CAAC;UAAE/B,IAAI;UAAEwB;QAAO,CAAC,CAAC,CAAC,CAAC;MACpE;IACF,CAAC,CAAC;EACJ;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}